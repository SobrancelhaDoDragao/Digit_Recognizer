{"ast":null,"code":"import { createElementVNode as _createElementVNode, createTextVNode as _createTextVNode, resolveComponent as _resolveComponent, withModifiers as _withModifiers, withCtx as _withCtx, createVNode as _createVNode, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\nconst _hoisted_1 = {\n  class: \"containerQuadro\",\n  ref: \"containerQuadro\"\n};\nconst _hoisted_2 = {\n  ref: \"canvas\",\n  id: \"quadro\"\n};\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_router_link = _resolveComponent(\"router-link\");\n  return _openBlock(), _createElementBlock(_Fragment, null, [_createElementVNode(\"div\", _hoisted_1, [_createElementVNode(\"canvas\", _hoisted_2, null, 512 /* NEED_PATCH */)], 512 /* NEED_PATCH */), _createVNode(_component_router_link, {\n    onClick: _withModifiers($options.salvarCanvas, [\"prevent\"]),\n    class: \"BotaoComum\",\n    to: {\n      name: 'PredictDigit',\n      params: {\n        digit: $data.digit\n      }\n    }\n  }, {\n    default: _withCtx(() => [_createTextVNode(\"Pronto\")]),\n    _: 1 /* STABLE */\n  }, 8 /* PROPS */, [\"onClick\", \"to\"])], 64 /* STABLE_FRAGMENT */);\n}","map":{"version":3,"names":["class","ref","id","_createElementVNode","_hoisted_1","_hoisted_2","_createVNode","_component_router_link","onClick","_withModifiers","$options","salvarCanvas","to","name","params","digit","$data"],"sources":["/home/eudson/Documentos/digit_recognizer/src/components/Quadro.vue"],"sourcesContent":["<template>\n\n     <div class=\"containerQuadro\" ref=\"containerQuadro\" >\n\n        <canvas ref=\"canvas\" id=\"quadro\"></canvas>\n                 \n        </div>\n\n        <router-link @click.prevent=\"salvarCanvas\" class='BotaoComum' :to=\"{name:'PredictDigit',params:{digit:digit}}\" >Pronto</router-link>\n \n</template>\n\n\n<script>\n\n    export default {\n\n        data(){\n            return{\n              digit:2\n            }\n        },\n        \n        methods:{\n\n            async salvarCanvas() {\n            \n            // Obtém o elemento canvas\n            const canvas = this.$refs.canvas;\n            \n            // Obtém o objeto de contexto do canvas\n            const ctx = canvas.getContext('2d');\n             \n            \n            let DataUrl = canvas.toDataURL('image/png')\n\n        \n\n            const csrfToken = await this.GetToken();\n            // Enviar o DataURL para o servidor usando Fetch\n                \n            const reponse = await fetch('http://127.0.0.1:8000/PredictDigit', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-CSRFToken': csrfToken,\n                },\n                body: JSON.stringify({'data_url': DataUrl}),\n            });\n\n            this.digit = await reponse.json()\n\n            con\n        },\n\n        async GetToken(){\n\n            const response = await fetch('http://127.0.0.1:8000/get_csrf');\n             \n            let dado = await response.json();\n\n            let csrfToken = await dado.csrf_token;\n\n            return csrfToken;\n\n        }\n    },\n        mounted() {\n\n            let penSize = 5\n            let isDrawing;\n            let x;\n            let y;\n            \n            const canvas = this.$refs.canvas;\n            const c = canvas.getContext(\"2d\");\n            \n            const sizeCanvas = () => {\n                const container = this.$refs.containerQuadro;\n                canvas.width = container.clientWidth;\n                canvas.height = container.clientHeight;\n            }\n\n            sizeCanvas();\n            \n            addEventListener(\"resize\", sizeCanvas); \n            \n            canvas.addEventListener(\"mousedown\",(e)=>{\n                isDrawing = true;\n                x = e.offsetX;\n                y = e.offsetY;\n            });\n            \n            canvas.addEventListener(\"mouseup\",()=>{\n            isDrawing = false;\n            x = undefined;\n            y = undefined;\n            })\n            \n            canvas.addEventListener(\"mousemove\",(event)=>{\n            draw(event.offsetX,event.offsetY)\n            })\n            \n            c.fillStyle = \"black\"\n            c.strokeStyle = c.fillStyle\n            \n            function draw(x2,y2){\n            if(isDrawing){\n                c.beginPath();\n                c.arc(x2,y2,penSize,0,Math.PI * 2);\n                c.closePath();\n                c.fill();\n            \n                //draw line\n                drawLine(x,y,x2,y2);\n            }\n            \n            x = x2;\n            y = y2;\n            }\n            \n            function drawLine(x1,y1,x2,y2){\n            c.beginPath();\n            c.moveTo(x1,y1);\n            c.lineTo(x2,y2);\n            c.strokeStyle = c.fillStyle;\n            c.lineWidth = penSize * 2;\n            c.stroke();\n            }\n        }\n    }\n\n</script>\n"],"mappings":";;EAEUA,KAAK,EAAC,iBAAiB;EAACC,GAAG,EAAC;;;EAEtBA,GAAG,EAAC,QAAQ;EAACC,EAAE,EAAC;;;;6DAF3BC,mBAAA,CAIS,OAJTC,UAIS,GAFND,mBAAA,CAA0C,UAA1CE,UAA0C,8B,yBAI1CC,YAAA,CAAoIC,sBAAA;IAAtHC,OAAK,EAAAC,cAAA,CAAUC,QAAA,CAAAC,YAAY;IAAEX,KAAK,EAAC,YAAY;IAAEY,EAAE;MAAAC,IAAA;MAAAC,MAAA;QAAAC,KAAA,EAAqCC,KAAA,CAAAD;MAAK;IAAA;;sBAAK,MAAM,C,iBAAN,QAAM,E"},"metadata":{},"sourceType":"module","externalDependencies":[]}